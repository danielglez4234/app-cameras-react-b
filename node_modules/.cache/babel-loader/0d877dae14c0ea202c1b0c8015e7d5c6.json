{"ast":null,"code":"/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* global RTCSessionDescription */\n\n/* global RTCIceCandidate */\n\n/* jshint -W097 */\n\"use strict\";\n\nvar transform = require('./transform');\n\nvar arrayEquals = require('./array-equals');\n\nfunction Interop() {\n  /**\n   * This map holds the most recent Unified Plan offer/answer SDP that was\n   * converted to Plan B, with the SDP type ('offer' or 'answer') as keys and\n   * the SDP string as values.\n   *\n   * @type {{}}\n   */\n  this.cache = {\n    mlB2UMap: {},\n    mlU2BMap: {}\n  };\n}\n\nmodule.exports = Interop;\n/**\n * Changes the candidate args to match with the related Unified Plan\n */\n\nInterop.prototype.candidateToUnifiedPlan = function (candidate) {\n  var cand = new RTCIceCandidate(candidate);\n  cand.sdpMLineIndex = this.cache.mlB2UMap[cand.sdpMLineIndex];\n  /* TODO: change sdpMid to (audio|video)-SSRC */\n\n  return cand;\n};\n/**\n * Changes the candidate args to match with the related Plan B\n */\n\n\nInterop.prototype.candidateToPlanB = function (candidate) {\n  var cand = new RTCIceCandidate(candidate);\n\n  if (cand.sdpMid.indexOf('audio') === 0) {\n    cand.sdpMid = 'audio';\n  } else if (cand.sdpMid.indexOf('video') === 0) {\n    cand.sdpMid = 'video';\n  } else {\n    throw new Error('candidate with ' + cand.sdpMid + ' not allowed');\n  }\n\n  cand.sdpMLineIndex = this.cache.mlU2BMap[cand.sdpMLineIndex];\n  return cand;\n};\n/**\n * Returns the index of the first m-line with the given media type and with a\n * direction which allows sending, in the last Unified Plan description with\n * type \"answer\" converted to Plan B. Returns {null} if there is no saved\n * answer, or if none of its m-lines with the given type allow sending.\n * @param type the media type (\"audio\" or \"video\").\n * @returns {*}\n */\n\n\nInterop.prototype.getFirstSendingIndexFromAnswer = function (type) {\n  if (!this.cache.answer) {\n    return null;\n  }\n\n  var session = transform.parse(this.cache.answer);\n\n  if (session && session.media && Array.isArray(session.media)) {\n    for (var i = 0; i < session.media.length; i++) {\n      if (session.media[i].type == type && (!session.media[i].direction\n      /* default to sendrecv */\n      || session.media[i].direction === 'sendrecv' || session.media[i].direction === 'sendonly')) {\n        return i;\n      }\n    }\n  }\n\n  return null;\n};\n/**\n * This method transforms a Unified Plan SDP to an equivalent Plan B SDP. A\n * PeerConnection wrapper transforms the SDP to Plan B before passing it to the\n * application.\n *\n * @param desc\n * @returns {*}\n */\n\n\nInterop.prototype.toPlanB = function (desc) {\n  var self = this; //#region Preliminary input validation.\n\n  if (typeof desc !== 'object' || desc === null || typeof desc.sdp !== 'string') {\n    console.warn('An empty description was passed as an argument.');\n    return desc;\n  } // Objectify the SDP for easier manipulation.\n\n\n  var session = transform.parse(desc.sdp); // If the SDP contains no media, there's nothing to transform.\n\n  if (typeof session.media === 'undefined' || !Array.isArray(session.media) || session.media.length === 0) {\n    console.warn('The description has no media.');\n    return desc;\n  } // Try some heuristics to \"make sure\" this is a Unified Plan SDP. Plan B\n  // SDP has a video, an audio and a data \"channel\" at most.\n\n\n  if (session.media.length <= 3 && session.media.every(function (m) {\n    return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\n  })) {\n    console.warn('This description does not look like Unified Plan.');\n    return desc;\n  } //#endregion\n  // HACK https://bugzilla.mozilla.org/show_bug.cgi?id=1113443\n\n\n  var sdp = desc.sdp;\n  var rewrite = false;\n\n  for (var i = 0; i < session.media.length; i++) {\n    var uLine = session.media[i];\n    uLine.rtp.forEach(function (rtp) {\n      if (rtp.codec === 'NULL') {\n        rewrite = true;\n        var offer = transform.parse(self.cache.offer);\n        rtp.codec = offer.media[i].rtp[0].codec;\n      }\n    });\n  }\n\n  if (rewrite) {\n    sdp = transform.write(session);\n  } // Unified Plan SDP is our \"precious\". Cache it for later use in the Plan B\n  // -> Unified Plan transformation.\n\n\n  this.cache[desc.type] = sdp; //#region Convert from Unified Plan to Plan B.\n  // We rebuild the session.media array.\n\n  var media = session.media;\n  session.media = []; // Associative array that maps channel types to channel objects for fast\n  // access to channel objects by their type, e.g. type2bl['audio']->channel\n  // obj.\n\n  var type2bl = {}; // Used to build the group:BUNDLE value after the channels construction\n  // loop.\n\n  var types = [];\n  media.forEach(function (uLine) {\n    // rtcp-mux is required in the Plan B SDP.\n    if ((typeof uLine.rtcpMux !== 'string' || uLine.rtcpMux !== 'rtcp-mux') && uLine.direction !== 'inactive') {\n      throw new Error('Cannot convert to Plan B because m-lines ' + 'without the rtcp-mux attribute were found.');\n    } // If we don't have a channel for this uLine.type OR the selected is\n    // inactive, then select this uLine as the channel basis.\n\n\n    if (typeof type2bl[uLine.type] === 'undefined' || type2bl[uLine.type].direction === 'inactive') {\n      type2bl[uLine.type] = uLine;\n    }\n\n    if (uLine.protocol != type2bl[uLine.type].protocol) {\n      throw new Error('Cannot convert to Plan B because m-lines ' + 'have different protocols and this library does not have ' + 'support for that');\n    }\n\n    if (uLine.payloads != type2bl[uLine.type].payloads) {\n      throw new Error('Cannot convert to Plan B because m-lines ' + 'have different payloads and this library does not have ' + 'support for that');\n    }\n  }); // Implode the Unified Plan m-lines/tracks into Plan B channels.\n\n  media.forEach(function (uLine) {\n    if (uLine.type === 'application') {\n      session.media.push(uLine);\n      types.push(uLine.mid);\n      return;\n    } // Add sources to the channel and handle a=msid.\n\n\n    if (typeof uLine.sources === 'object') {\n      Object.keys(uLine.sources).forEach(function (ssrc) {\n        if (typeof type2bl[uLine.type].sources !== 'object') type2bl[uLine.type].sources = {}; // Assign the sources to the channel.\n\n        type2bl[uLine.type].sources[ssrc] = uLine.sources[ssrc];\n\n        if (typeof uLine.msid !== 'undefined') {\n          // In Plan B the msid is an SSRC attribute. Also, we don't\n          // care about the obsolete label and mslabel attributes.\n          //\n          // Note that it is not guaranteed that the uLine will\n          // have an msid. recvonly channels in particular don't have\n          // one.\n          type2bl[uLine.type].sources[ssrc].msid = uLine.msid;\n        } // NOTE ssrcs in ssrc groups will share msids, as\n        // draft-uberti-rtcweb-plan-00 mandates.\n\n      });\n    } // Add ssrc groups to the channel.\n\n\n    if (typeof uLine.ssrcGroups !== 'undefined' && Array.isArray(uLine.ssrcGroups)) {\n      // Create the ssrcGroups array, if it's not defined.\n      if (typeof type2bl[uLine.type].ssrcGroups === 'undefined' || !Array.isArray(type2bl[uLine.type].ssrcGroups)) {\n        type2bl[uLine.type].ssrcGroups = [];\n      }\n\n      type2bl[uLine.type].ssrcGroups = type2bl[uLine.type].ssrcGroups.concat(uLine.ssrcGroups);\n    }\n\n    if (type2bl[uLine.type] === uLine) {\n      // Plan B mids are in ['audio', 'video', 'data']\n      uLine.mid = uLine.type; // Plan B doesn't support/need the bundle-only attribute.\n\n      delete uLine.bundleOnly; // In Plan B the msid is an SSRC attribute.\n\n      delete uLine.msid;\n\n      if (uLine.type == media[0].type) {\n        types.unshift(uLine.type); // Add the channel to the new media array.\n\n        session.media.unshift(uLine);\n      } else {\n        types.push(uLine.type); // Add the channel to the new media array.\n\n        session.media.push(uLine);\n      }\n    }\n  });\n\n  if (typeof session.groups !== 'undefined') {\n    // We regenerate the BUNDLE group with the new mids.\n    session.groups.some(function (group) {\n      if (group.type === 'BUNDLE') {\n        group.mids = types.join(' ');\n        return true;\n      }\n    });\n  } // msid semantic\n\n\n  session.msidSemantic = {\n    semantic: 'WMS',\n    token: '*'\n  };\n  var resStr = transform.write(session);\n  return new RTCSessionDescription({\n    type: desc.type,\n    sdp: resStr\n  }); //#endregion\n};\n/* follow rules defined in RFC4145 */\n\n\nfunction addSetupAttr(uLine) {\n  if (typeof uLine.setup === 'undefined') {\n    return;\n  }\n\n  if (uLine.setup === \"active\") {\n    uLine.setup = \"passive\";\n  } else if (uLine.setup === \"passive\") {\n    uLine.setup = \"active\";\n  }\n}\n/**\n * This method transforms a Plan B SDP to an equivalent Unified Plan SDP. A\n * PeerConnection wrapper transforms the SDP to Unified Plan before passing it\n * to FF.\n *\n * @param desc\n * @returns {*}\n */\n\n\nInterop.prototype.toUnifiedPlan = function (desc) {\n  var self = this; //#region Preliminary input validation.\n\n  if (typeof desc !== 'object' || desc === null || typeof desc.sdp !== 'string') {\n    console.warn('An empty description was passed as an argument.');\n    return desc;\n  }\n\n  var session = transform.parse(desc.sdp); // If the SDP contains no media, there's nothing to transform.\n\n  if (typeof session.media === 'undefined' || !Array.isArray(session.media) || session.media.length === 0) {\n    console.warn('The description has no media.');\n    return desc;\n  } // Try some heuristics to \"make sure\" this is a Plan B SDP. Plan B SDP has\n  // a video, an audio and a data \"channel\" at most.\n\n\n  if (session.media.length > 3 || !session.media.every(function (m) {\n    return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\n  })) {\n    console.warn('This description does not look like Plan B.');\n    return desc;\n  } // Make sure this Plan B SDP can be converted to a Unified Plan SDP.\n\n\n  var mids = [];\n  session.media.forEach(function (m) {\n    mids.push(m.mid);\n  });\n  var hasBundle = false;\n\n  if (typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {\n    hasBundle = session.groups.every(function (g) {\n      return g.type !== 'BUNDLE' || arrayEquals.apply(g.mids.sort(), [mids.sort()]);\n    });\n  }\n\n  if (!hasBundle) {\n    var mustBeBundle = false;\n    session.media.forEach(function (m) {\n      if (m.direction !== 'inactive') {\n        mustBeBundle = true;\n      }\n    });\n\n    if (mustBeBundle) {\n      throw new Error(\"Cannot convert to Unified Plan because m-lines that\" + \" are not bundled were found.\");\n    }\n  } //#endregion\n  //#region Convert from Plan B to Unified Plan.\n  // Unfortunately, a Plan B offer/answer doesn't have enough information to\n  // rebuild an equivalent Unified Plan offer/answer.\n  //\n  // For example, if this is a local answer (in Unified Plan style) that we\n  // convert to Plan B prior to handing it over to the application (the\n  // PeerConnection wrapper called us, for instance, after a successful\n  // createAnswer), we want to remember the m-line at which we've seen the\n  // (local) SSRC. That's because when the application wants to do call the\n  // SLD method, forcing us to do the inverse transformation (from Plan B to\n  // Unified Plan), we need to know to which m-line to assign the (local)\n  // SSRC. We also need to know all the other m-lines that the original\n  // answer had and include them in the transformed answer as well.\n  //\n  // Another example is if this is a remote offer that we convert to Plan B\n  // prior to giving it to the application, we want to remember the mid at\n  // which we've seen the (remote) SSRC.\n  //\n  // In the iteration that follows, we use the cached Unified Plan (if it\n  // exists) to assign mids to ssrcs.\n\n\n  var type;\n\n  if (desc.type === 'answer') {\n    type = 'offer';\n  } else if (desc.type === 'offer') {\n    type = 'answer';\n  } else {\n    throw new Error(\"Type '\" + desc.type + \"' not supported.\");\n  }\n\n  var cached;\n\n  if (typeof this.cache[type] !== 'undefined') {\n    cached = transform.parse(this.cache[type]);\n  }\n\n  var recvonlySsrcs = {\n    audio: {},\n    video: {}\n  }; // A helper map that sends mids to m-line objects. We use it later to\n  // rebuild the Unified Plan style session.media array.\n\n  var mid2ul = {};\n  var bIdx = 0;\n  var uIdx = 0;\n  var sources2ul = {};\n  var candidates;\n  var iceUfrag;\n  var icePwd;\n  var fingerprint;\n  var payloads = {};\n  var rtcpFb = {};\n  var rtp = {};\n  session.media.forEach(function (bLine) {\n    if ((typeof bLine.rtcpMux !== 'string' || bLine.rtcpMux !== 'rtcp-mux') && bLine.direction !== 'inactive') {\n      throw new Error(\"Cannot convert to Unified Plan because m-lines \" + \"without the rtcp-mux attribute were found.\");\n    }\n\n    if (bLine.type === 'application') {\n      mid2ul[bLine.mid] = bLine;\n      return;\n    } // With rtcp-mux and bundle all the channels should have the same ICE\n    // stuff.\n\n\n    var sources = bLine.sources;\n    var ssrcGroups = bLine.ssrcGroups;\n    var port = bLine.port;\n    /* Chrome adds different candidates even using bundle, so we concat the candidates list */\n\n    if (typeof bLine.candidates != 'undefined') {\n      if (typeof candidates != 'undefined') {\n        candidates = candidates.concat(bLine.candidates);\n      } else {\n        candidates = bLine.candidates;\n      }\n    }\n\n    if (typeof iceUfrag != 'undefined' && typeof bLine.iceUfrag != 'undefined' && iceUfrag != bLine.iceUfrag) {\n      throw new Error(\"Only BUNDLE supported, iceUfrag must be the same for all m-lines.\\n\" + \"\\tLast iceUfrag: \" + iceUfrag + \"\\n\" + \"\\tNew iceUfrag: \" + bLine.iceUfrag);\n    }\n\n    if (typeof bLine.iceUfrag != 'undefined') {\n      iceUfrag = bLine.iceUfrag;\n    }\n\n    if (typeof icePwd != 'undefined' && typeof bLine.icePwd != 'undefined' && icePwd != bLine.icePwd) {\n      throw new Error(\"Only BUNDLE supported, icePwd must be the same for all m-lines.\\n\" + \"\\tLast icePwd: \" + icePwd + \"\\n\" + \"\\tNew icePwd: \" + bLine.icePwd);\n    }\n\n    if (typeof bLine.icePwd != 'undefined') {\n      icePwd = bLine.icePwd;\n    }\n\n    if (typeof fingerprint != 'undefined' && typeof bLine.fingerprint != 'undefined' && (fingerprint.type != bLine.fingerprint.type || fingerprint.hash != bLine.fingerprint.hash)) {\n      throw new Error(\"Only BUNDLE supported, fingerprint must be the same for all m-lines.\\n\" + \"\\tLast fingerprint: \" + JSON.stringify(fingerprint) + \"\\n\" + \"\\tNew fingerprint: \" + JSON.stringify(bLine.fingerprint));\n    }\n\n    if (typeof bLine.fingerprint != 'undefined') {\n      fingerprint = bLine.fingerprint;\n    }\n\n    payloads[bLine.type] = bLine.payloads;\n    rtcpFb[bLine.type] = bLine.rtcpFb;\n    rtp[bLine.type] = bLine.rtp; // inverted ssrc group map\n\n    var ssrc2group = {};\n\n    if (typeof ssrcGroups !== 'undefined' && Array.isArray(ssrcGroups)) {\n      ssrcGroups.forEach(function (ssrcGroup) {\n        // XXX This might brake if an SSRC is in more than one group\n        // for some reason.\n        if (typeof ssrcGroup.ssrcs !== 'undefined' && Array.isArray(ssrcGroup.ssrcs)) {\n          ssrcGroup.ssrcs.forEach(function (ssrc) {\n            if (typeof ssrc2group[ssrc] === 'undefined') {\n              ssrc2group[ssrc] = [];\n            }\n\n            ssrc2group[ssrc].push(ssrcGroup);\n          });\n        }\n      });\n    } // ssrc to m-line index.\n\n\n    var ssrc2ml = {};\n\n    if (typeof sources === 'object') {\n      // We'll use the \"bLine\" object as a prototype for each new \"mLine\"\n      // that we create, but first we need to clean it up a bit.\n      delete bLine.sources;\n      delete bLine.ssrcGroups;\n      delete bLine.candidates;\n      delete bLine.iceUfrag;\n      delete bLine.icePwd;\n      delete bLine.fingerprint;\n      delete bLine.port;\n      delete bLine.mid; // Explode the Plan B channel sources with one m-line per source.\n\n      Object.keys(sources).forEach(function (ssrc) {\n        // The (unified) m-line for this SSRC. We either create it from\n        // scratch or, if it's a grouped SSRC, we re-use a related\n        // mline. In other words, if the source is grouped with another\n        // source, put the two together in the same m-line.\n        var uLine; // We assume here that we are the answerer in the O/A, so any\n        // offers which we translate come from the remote side, while\n        // answers are local. So the check below is to make that we\n        // handle receive-only SSRCs in a special way only if they come\n        // from the remote side.\n\n        if (desc.type === 'offer') {\n          // We want to detect SSRCs which are used by a remote peer\n          // in an m-line with direction=recvonly (i.e. they are\n          // being used for RTCP only).\n          // This information would have gotten lost if the remote\n          // peer used Unified Plan and their local description was\n          // translated to Plan B. So we use the lack of an MSID\n          // attribute to deduce a \"receive only\" SSRC.\n          if (!sources[ssrc].msid) {\n            recvonlySsrcs[bLine.type][ssrc] = sources[ssrc]; // Receive-only SSRCs must not create new m-lines. We\n            // will assign them to an existing m-line later.\n\n            return;\n          }\n        }\n\n        if (typeof ssrc2group[ssrc] !== 'undefined' && Array.isArray(ssrc2group[ssrc])) {\n          ssrc2group[ssrc].some(function (ssrcGroup) {\n            // ssrcGroup.ssrcs *is* an Array, no need to check\n            // again here.\n            return ssrcGroup.ssrcs.some(function (related) {\n              if (typeof ssrc2ml[related] === 'object') {\n                uLine = ssrc2ml[related];\n                return true;\n              }\n            });\n          });\n        }\n\n        if (typeof uLine === 'object') {\n          // the m-line already exists. Just add the source.\n          uLine.sources[ssrc] = sources[ssrc];\n          delete sources[ssrc].msid;\n        } else {\n          // Use the \"bLine\" as a prototype for the \"uLine\".\n          uLine = Object.create(bLine);\n          ssrc2ml[ssrc] = uLine;\n\n          if (typeof sources[ssrc].msid !== 'undefined') {\n            // Assign the msid of the source to the m-line. Note\n            // that it is not guaranteed that the source will have\n            // msid. In particular \"recvonly\" sources don't have an\n            // msid. Note that \"recvonly\" is a term only defined\n            // for m-lines.\n            uLine.msid = sources[ssrc].msid;\n            delete sources[ssrc].msid;\n          } // We assign one SSRC per media line.\n\n\n          uLine.sources = {};\n          uLine.sources[ssrc] = sources[ssrc];\n          uLine.ssrcGroups = ssrc2group[ssrc]; // Use the cached Unified Plan SDP (if it exists) to assign\n          // SSRCs to mids.\n\n          if (typeof cached !== 'undefined' && typeof cached.media !== 'undefined' && Array.isArray(cached.media)) {\n            cached.media.forEach(function (m) {\n              if (typeof m.sources === 'object') {\n                Object.keys(m.sources).forEach(function (s) {\n                  if (s === ssrc) {\n                    uLine.mid = m.mid;\n                  }\n                });\n              }\n            });\n          }\n\n          if (typeof uLine.mid === 'undefined') {\n            // If this is an SSRC that we see for the first time\n            // assign it a new mid. This is typically the case when\n            // this method is called to transform a remote\n            // description for the first time or when there is a\n            // new SSRC in the remote description because a new\n            // peer has joined the conference. Local SSRCs should\n            // have already been added to the map in the toPlanB\n            // method.\n            //\n            // Because FF generates answers in Unified Plan style,\n            // we MUST already have a cached answer with all the\n            // local SSRCs mapped to some m-line/mid.\n            uLine.mid = [bLine.type, '-', ssrc].join('');\n          } // Include the candidates in the 1st media line.\n\n\n          uLine.candidates = candidates;\n          uLine.iceUfrag = iceUfrag;\n          uLine.icePwd = icePwd;\n          uLine.fingerprint = fingerprint;\n          uLine.port = port;\n          mid2ul[uLine.mid] = uLine;\n          sources2ul[uIdx] = uLine.sources;\n          self.cache.mlU2BMap[uIdx] = bIdx;\n\n          if (typeof self.cache.mlB2UMap[bIdx] === 'undefined') {\n            self.cache.mlB2UMap[bIdx] = uIdx;\n          }\n\n          uIdx++;\n        }\n      });\n    } else {\n      var uLine = bLine;\n      uLine.candidates = candidates;\n      uLine.iceUfrag = iceUfrag;\n      uLine.icePwd = icePwd;\n      uLine.fingerprint = fingerprint;\n      uLine.port = port;\n      mid2ul[uLine.mid] = uLine;\n      self.cache.mlU2BMap[uIdx] = bIdx;\n\n      if (typeof self.cache.mlB2UMap[bIdx] === 'undefined') {\n        self.cache.mlB2UMap[bIdx] = uIdx;\n      }\n    }\n\n    bIdx++;\n  }); // Rebuild the media array in the right order and add the missing mLines\n  // (missing from the Plan B SDP).\n\n  session.media = [];\n  mids = []; // reuse\n\n  if (desc.type === 'answer') {\n    // The media lines in the answer must match the media lines in the\n    // offer. The order is important too. Here we assume that Firefox is\n    // the answerer, so we merely have to use the reconstructed (unified)\n    // answer to update the cached (unified) answer accordingly.\n    //\n    // In the general case, one would have to use the cached (unified)\n    // offer to find the m-lines that are missing from the reconstructed\n    // answer, potentially grabbing them from the cached (unified) answer.\n    // One has to be careful with this approach because inactive m-lines do\n    // not always have an mid, making it tricky (impossible?) to find where\n    // exactly and which m-lines are missing from the reconstructed answer.\n    for (var i = 0; i < cached.media.length; i++) {\n      var uLine = cached.media[i];\n      delete uLine.msid;\n      delete uLine.sources;\n      delete uLine.ssrcGroups;\n\n      if (typeof sources2ul[i] === 'undefined') {\n        if (!uLine.direction || uLine.direction === 'sendrecv') uLine.direction = 'recvonly';else if (uLine.direction === 'sendonly') uLine.direction = 'inactive';\n      } else {\n        if (!uLine.direction || uLine.direction === 'sendrecv') uLine.direction = 'sendrecv';else if (uLine.direction === 'recvonly') uLine.direction = 'sendonly';\n      }\n\n      uLine.sources = sources2ul[i];\n      uLine.candidates = candidates;\n      uLine.iceUfrag = iceUfrag;\n      uLine.icePwd = icePwd;\n      uLine.fingerprint = fingerprint;\n      uLine.rtp = rtp[uLine.type];\n      uLine.payloads = payloads[uLine.type];\n      uLine.rtcpFb = rtcpFb[uLine.type];\n      session.media.push(uLine);\n\n      if (typeof uLine.mid === 'string') {\n        // inactive lines don't/may not have an mid.\n        mids.push(uLine.mid);\n      }\n    }\n  } else {\n    // SDP offer/answer (and the JSEP spec) forbids removing an m-section\n    // under any circumstances. If we are no longer interested in sending a\n    // track, we just remove the msid and ssrc attributes and set it to\n    // either a=recvonly (as the reofferer, we must use recvonly if the\n    // other side was previously sending on the m-section, but we can also\n    // leave the possibility open if it wasn't previously in use), or\n    // a=inactive.\n    if (typeof cached !== 'undefined' && typeof cached.media !== 'undefined' && Array.isArray(cached.media)) {\n      cached.media.forEach(function (uLine) {\n        mids.push(uLine.mid);\n\n        if (typeof mid2ul[uLine.mid] !== 'undefined') {\n          session.media.push(mid2ul[uLine.mid]);\n        } else {\n          delete uLine.msid;\n          delete uLine.sources;\n          delete uLine.ssrcGroups;\n\n          if (!uLine.direction || uLine.direction === 'sendrecv') {\n            uLine.direction = 'sendonly';\n          }\n\n          if (!uLine.direction || uLine.direction === 'recvonly') {\n            uLine.direction = 'inactive';\n          }\n\n          addSetupAttr(uLine);\n          session.media.push(uLine);\n        }\n      });\n    } // Add all the remaining (new) m-lines of the transformed SDP.\n\n\n    Object.keys(mid2ul).forEach(function (mid) {\n      if (mids.indexOf(mid) === -1) {\n        mids.push(mid);\n\n        if (mid2ul[mid].direction === 'recvonly') {\n          // This is a remote recvonly channel. Add its SSRC to the\n          // appropriate sendrecv or sendonly channel.\n          // TODO(gp) what if we don't have sendrecv/sendonly\n          // channel?\n          var done = false;\n          session.media.some(function (uLine) {\n            if ((uLine.direction === 'sendrecv' || uLine.direction === 'sendonly') && uLine.type === mid2ul[mid].type) {\n              // mid2ul[mid] shouldn't have any ssrc-groups\n              Object.keys(mid2ul[mid].sources).forEach(function (ssrc) {\n                uLine.sources[ssrc] = mid2ul[mid].sources[ssrc];\n              });\n              done = true;\n              return true;\n            }\n          });\n\n          if (!done) {\n            session.media.push(mid2ul[mid]);\n          }\n        } else {\n          session.media.push(mid2ul[mid]);\n        }\n      }\n    });\n  } // After we have constructed the Plan Unified m-lines we can figure out\n  // where (in which m-line) to place the 'recvonly SSRCs'.\n  // Note: we assume here that we are the answerer in the O/A, so any offers\n  // which we translate come from the remote side, while answers are local\n  // (and so our last local description is cached as an 'answer').\n\n\n  [\"audio\", \"video\"].forEach(function (type) {\n    if (!session || !session.media || !Array.isArray(session.media)) return;\n    var idx = null;\n\n    if (Object.keys(recvonlySsrcs[type]).length > 0) {\n      idx = self.getFirstSendingIndexFromAnswer(type);\n\n      if (idx === null) {\n        // If this is the first offer we receive, we don't have a\n        // cached answer. Assume that we will be sending media using\n        // the first m-line for each media type.\n        for (var i = 0; i < session.media.length; i++) {\n          if (session.media[i].type === type) {\n            idx = i;\n            break;\n          }\n        }\n      }\n    }\n\n    if (idx && session.media.length > idx) {\n      var mLine = session.media[idx];\n      Object.keys(recvonlySsrcs[type]).forEach(function (ssrc) {\n        if (mLine.sources && mLine.sources[ssrc]) {\n          console.warn(\"Replacing an existing SSRC.\");\n        }\n\n        if (!mLine.sources) {\n          mLine.sources = {};\n        }\n\n        mLine.sources[ssrc] = recvonlySsrcs[type][ssrc];\n      });\n    }\n  });\n\n  if (typeof session.groups !== 'undefined') {\n    // We regenerate the BUNDLE group (since we regenerated the mids)\n    session.groups.some(function (group) {\n      if (group.type === 'BUNDLE') {\n        group.mids = mids.join(' ');\n        return true;\n      }\n    });\n  } // msid semantic\n\n\n  session.msidSemantic = {\n    semantic: 'WMS',\n    token: '*'\n  };\n  var resStr = transform.write(session); // Cache the transformed SDP (Unified Plan) for later re-use in this\n  // function.\n\n  this.cache[desc.type] = resStr;\n  return new RTCSessionDescription({\n    type: desc.type,\n    sdp: resStr\n  }); //#endregion\n};","map":{"version":3,"sources":["C:/Users/dgonzalez/Documents/Instalación conectada/web-cameras/app-cameras-react-b/node_modules/sdp-translator/lib/interop.js"],"names":["transform","require","arrayEquals","Interop","cache","mlB2UMap","mlU2BMap","module","exports","prototype","candidateToUnifiedPlan","candidate","cand","RTCIceCandidate","sdpMLineIndex","candidateToPlanB","sdpMid","indexOf","Error","getFirstSendingIndexFromAnswer","type","answer","session","parse","media","Array","isArray","i","length","direction","toPlanB","desc","self","sdp","console","warn","every","m","mid","rewrite","uLine","rtp","forEach","codec","offer","write","type2bl","types","rtcpMux","protocol","payloads","push","sources","Object","keys","ssrc","msid","ssrcGroups","concat","bundleOnly","unshift","groups","some","group","mids","join","msidSemantic","semantic","token","resStr","RTCSessionDescription","addSetupAttr","setup","toUnifiedPlan","hasBundle","g","apply","sort","mustBeBundle","cached","recvonlySsrcs","audio","video","mid2ul","bIdx","uIdx","sources2ul","candidates","iceUfrag","icePwd","fingerprint","rtcpFb","bLine","port","hash","JSON","stringify","ssrc2group","ssrcGroup","ssrcs","ssrc2ml","related","create","s","done","idx","mLine"],"mappings":"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","sourcesContent":["/* Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* global RTCSessionDescription */\n/* global RTCIceCandidate */\n/* jshint -W097 */\n\"use strict\";\n\nvar transform = require('./transform');\nvar arrayEquals = require('./array-equals');\n\nfunction Interop() {\n\n    /**\n     * This map holds the most recent Unified Plan offer/answer SDP that was\n     * converted to Plan B, with the SDP type ('offer' or 'answer') as keys and\n     * the SDP string as values.\n     *\n     * @type {{}}\n     */\n    this.cache = {\n        mlB2UMap : {},\n        mlU2BMap : {}\n    };\n}\n\nmodule.exports = Interop;\n\n/**\n * Changes the candidate args to match with the related Unified Plan\n */\nInterop.prototype.candidateToUnifiedPlan = function(candidate) {\n    var cand = new RTCIceCandidate(candidate);\n\n    cand.sdpMLineIndex = this.cache.mlB2UMap[cand.sdpMLineIndex];\n    /* TODO: change sdpMid to (audio|video)-SSRC */\n\n    return cand;\n};\n\n/**\n * Changes the candidate args to match with the related Plan B\n */\nInterop.prototype.candidateToPlanB = function(candidate) {\n    var cand = new RTCIceCandidate(candidate);\n\n    if (cand.sdpMid.indexOf('audio') === 0) {\n      cand.sdpMid = 'audio';\n    } else if (cand.sdpMid.indexOf('video') === 0) {\n      cand.sdpMid = 'video';\n    } else {\n      throw new Error('candidate with ' + cand.sdpMid + ' not allowed');\n    }\n\n    cand.sdpMLineIndex = this.cache.mlU2BMap[cand.sdpMLineIndex];\n\n    return cand;\n};\n\n/**\n * Returns the index of the first m-line with the given media type and with a\n * direction which allows sending, in the last Unified Plan description with\n * type \"answer\" converted to Plan B. Returns {null} if there is no saved\n * answer, or if none of its m-lines with the given type allow sending.\n * @param type the media type (\"audio\" or \"video\").\n * @returns {*}\n */\nInterop.prototype.getFirstSendingIndexFromAnswer = function(type) {\n    if (!this.cache.answer) {\n        return null;\n    }\n\n    var session = transform.parse(this.cache.answer);\n    if (session && session.media && Array.isArray(session.media)){\n        for (var i = 0; i < session.media.length; i++) {\n            if (session.media[i].type == type &&\n                (!session.media[i].direction /* default to sendrecv */ ||\n                    session.media[i].direction === 'sendrecv' ||\n                    session.media[i].direction === 'sendonly')){\n                return i;\n            }\n        }\n    }\n\n    return null;\n};\n\n/**\n * This method transforms a Unified Plan SDP to an equivalent Plan B SDP. A\n * PeerConnection wrapper transforms the SDP to Plan B before passing it to the\n * application.\n *\n * @param desc\n * @returns {*}\n */\nInterop.prototype.toPlanB = function(desc) {\n    var self = this;\n    //#region Preliminary input validation.\n\n    if (typeof desc !== 'object' || desc === null ||\n        typeof desc.sdp !== 'string') {\n        console.warn('An empty description was passed as an argument.');\n        return desc;\n    }\n\n    // Objectify the SDP for easier manipulation.\n    var session = transform.parse(desc.sdp);\n\n    // If the SDP contains no media, there's nothing to transform.\n    if (typeof session.media === 'undefined' ||\n        !Array.isArray(session.media) || session.media.length === 0) {\n        console.warn('The description has no media.');\n        return desc;\n    }\n\n    // Try some heuristics to \"make sure\" this is a Unified Plan SDP. Plan B\n    // SDP has a video, an audio and a data \"channel\" at most.\n    if (session.media.length <= 3 && session.media.every(function(m) {\n            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\n        })) {\n        console.warn('This description does not look like Unified Plan.');\n        return desc;\n    }\n\n    //#endregion\n\n    // HACK https://bugzilla.mozilla.org/show_bug.cgi?id=1113443\n    var sdp = desc.sdp;\n    var rewrite = false;\n    for (var i = 0; i < session.media.length; i++) {\n        var uLine = session.media[i];\n        uLine.rtp.forEach(function(rtp) {\n            if (rtp.codec === 'NULL')\n            {\n                rewrite = true;\n                var offer = transform.parse(self.cache.offer);\n                rtp.codec = offer.media[i].rtp[0].codec;\n            }\n        });\n    }\n    if (rewrite) {\n        sdp = transform.write(session);\n    }\n\n    // Unified Plan SDP is our \"precious\". Cache it for later use in the Plan B\n    // -> Unified Plan transformation.\n    this.cache[desc.type] = sdp;\n\n    //#region Convert from Unified Plan to Plan B.\n\n    // We rebuild the session.media array.\n    var media = session.media;\n    session.media = [];\n\n    // Associative array that maps channel types to channel objects for fast\n    // access to channel objects by their type, e.g. type2bl['audio']->channel\n    // obj.\n    var type2bl = {};\n\n    // Used to build the group:BUNDLE value after the channels construction\n    // loop.\n    var types = [];\n\n    media.forEach(function(uLine) {\n        // rtcp-mux is required in the Plan B SDP.\n        if ((typeof uLine.rtcpMux !== 'string' ||\n            uLine.rtcpMux !== 'rtcp-mux') &&\n            uLine.direction !== 'inactive') {\n            throw new Error('Cannot convert to Plan B because m-lines ' +\n                'without the rtcp-mux attribute were found.');\n        }\n\n        // If we don't have a channel for this uLine.type OR the selected is\n        // inactive, then select this uLine as the channel basis.\n        if (typeof type2bl[uLine.type] === 'undefined' ||\n            type2bl[uLine.type].direction === 'inactive') {\n            type2bl[uLine.type] = uLine;\n        }\n\n        if (uLine.protocol != type2bl[uLine.type].protocol) {\n          throw new Error('Cannot convert to Plan B because m-lines ' +\n              'have different protocols and this library does not have ' +\n              'support for that');\n        }\n\n        if (uLine.payloads != type2bl[uLine.type].payloads) {\n          throw new Error('Cannot convert to Plan B because m-lines ' +\n              'have different payloads and this library does not have ' +\n              'support for that');\n        }\n\n    });\n\n    // Implode the Unified Plan m-lines/tracks into Plan B channels.\n    media.forEach(function(uLine) {\n        if (uLine.type === 'application') {\n            session.media.push(uLine);\n            types.push(uLine.mid);\n            return;\n        }\n\n        // Add sources to the channel and handle a=msid.\n        if (typeof uLine.sources === 'object') {\n            Object.keys(uLine.sources).forEach(function(ssrc) {\n                if (typeof type2bl[uLine.type].sources !== 'object')\n                    type2bl[uLine.type].sources = {};\n\n                // Assign the sources to the channel.\n                type2bl[uLine.type].sources[ssrc] =\n                    uLine.sources[ssrc];\n\n                if (typeof uLine.msid !== 'undefined') {\n                    // In Plan B the msid is an SSRC attribute. Also, we don't\n                    // care about the obsolete label and mslabel attributes.\n                    //\n                    // Note that it is not guaranteed that the uLine will\n                    // have an msid. recvonly channels in particular don't have\n                    // one.\n                    type2bl[uLine.type].sources[ssrc].msid =\n                        uLine.msid;\n                }\n                // NOTE ssrcs in ssrc groups will share msids, as\n                // draft-uberti-rtcweb-plan-00 mandates.\n            });\n        }\n\n        // Add ssrc groups to the channel.\n        if (typeof uLine.ssrcGroups !== 'undefined' &&\n                Array.isArray(uLine.ssrcGroups)) {\n\n            // Create the ssrcGroups array, if it's not defined.\n            if (typeof type2bl[uLine.type].ssrcGroups === 'undefined' ||\n                    !Array.isArray(type2bl[uLine.type].ssrcGroups)) {\n                type2bl[uLine.type].ssrcGroups = [];\n            }\n\n            type2bl[uLine.type].ssrcGroups =\n                type2bl[uLine.type].ssrcGroups.concat(\n                    uLine.ssrcGroups);\n        }\n\n        if (type2bl[uLine.type] === uLine) {\n            // Plan B mids are in ['audio', 'video', 'data']\n            uLine.mid = uLine.type;\n\n            // Plan B doesn't support/need the bundle-only attribute.\n            delete uLine.bundleOnly;\n\n            // In Plan B the msid is an SSRC attribute.\n            delete uLine.msid;\n\n\t    if (uLine.type == media[0].type) {\n\t      types.unshift(uLine.type);\n\t      // Add the channel to the new media array.\n\t      session.media.unshift(uLine);\n\t    } else {\n\t      types.push(uLine.type);\n\t      // Add the channel to the new media array.\n\t      session.media.push(uLine);\n\t    }\n        }\n    });\n\n    if (typeof session.groups !== 'undefined') {\n      // We regenerate the BUNDLE group with the new mids.\n      session.groups.some(function(group) {\n\t  if (group.type === 'BUNDLE') {\n\t      group.mids = types.join(' ');\n\t      return true;\n\t  }\n      });\n    }\n\n    // msid semantic\n    session.msidSemantic = {\n        semantic: 'WMS',\n        token: '*'\n    };\n\n    var resStr = transform.write(session);\n\n    return new RTCSessionDescription({\n        type: desc.type,\n        sdp: resStr\n    });\n\n    //#endregion\n};\n\n/* follow rules defined in RFC4145 */\nfunction addSetupAttr(uLine) {\n    if (typeof uLine.setup === 'undefined') {\n        return;\n    }\n\n    if (uLine.setup === \"active\") {\n            uLine.setup = \"passive\";\n    } else if (uLine.setup === \"passive\") {\n        uLine.setup = \"active\";\n    }\n}\n\n/**\n * This method transforms a Plan B SDP to an equivalent Unified Plan SDP. A\n * PeerConnection wrapper transforms the SDP to Unified Plan before passing it\n * to FF.\n *\n * @param desc\n * @returns {*}\n */\nInterop.prototype.toUnifiedPlan = function(desc) {\n    var self = this;\n    //#region Preliminary input validation.\n\n    if (typeof desc !== 'object' || desc === null ||\n        typeof desc.sdp !== 'string') {\n        console.warn('An empty description was passed as an argument.');\n        return desc;\n    }\n\n    var session = transform.parse(desc.sdp);\n\n    // If the SDP contains no media, there's nothing to transform.\n    if (typeof session.media === 'undefined' ||\n        !Array.isArray(session.media) || session.media.length === 0) {\n        console.warn('The description has no media.');\n        return desc;\n    }\n\n    // Try some heuristics to \"make sure\" this is a Plan B SDP. Plan B SDP has\n    // a video, an audio and a data \"channel\" at most.\n    if (session.media.length > 3 || !session.media.every(function(m) {\n            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;\n        })) {\n        console.warn('This description does not look like Plan B.');\n        return desc;\n    }\n\n    // Make sure this Plan B SDP can be converted to a Unified Plan SDP.\n    var mids = [];\n    session.media.forEach(function(m) {\n        mids.push(m.mid);\n    });\n\n    var hasBundle = false;\n    if (typeof session.groups !== 'undefined' &&\n        Array.isArray(session.groups)) {\n        hasBundle = session.groups.every(function(g) {\n            return g.type !== 'BUNDLE' ||\n                arrayEquals.apply(g.mids.sort(), [mids.sort()]);\n        });\n    }\n\n    if (!hasBundle) {\n        var mustBeBundle = false;\n\n        session.media.forEach(function(m) {\n            if (m.direction !== 'inactive') {\n                mustBeBundle = true;\n            }\n        });\n\n        if (mustBeBundle) {\n            throw new Error(\"Cannot convert to Unified Plan because m-lines that\" +\n              \" are not bundled were found.\");\n        }\n    }\n\n    //#endregion\n\n\n    //#region Convert from Plan B to Unified Plan.\n\n    // Unfortunately, a Plan B offer/answer doesn't have enough information to\n    // rebuild an equivalent Unified Plan offer/answer.\n    //\n    // For example, if this is a local answer (in Unified Plan style) that we\n    // convert to Plan B prior to handing it over to the application (the\n    // PeerConnection wrapper called us, for instance, after a successful\n    // createAnswer), we want to remember the m-line at which we've seen the\n    // (local) SSRC. That's because when the application wants to do call the\n    // SLD method, forcing us to do the inverse transformation (from Plan B to\n    // Unified Plan), we need to know to which m-line to assign the (local)\n    // SSRC. We also need to know all the other m-lines that the original\n    // answer had and include them in the transformed answer as well.\n    //\n    // Another example is if this is a remote offer that we convert to Plan B\n    // prior to giving it to the application, we want to remember the mid at\n    // which we've seen the (remote) SSRC.\n    //\n    // In the iteration that follows, we use the cached Unified Plan (if it\n    // exists) to assign mids to ssrcs.\n\n    var type;\n    if (desc.type === 'answer') {\n        type = 'offer';\n    } else if (desc.type === 'offer') {\n        type = 'answer';\n    } else {\n        throw new Error(\"Type '\" + desc.type + \"' not supported.\");\n    }\n\n    var cached;\n    if (typeof this.cache[type] !== 'undefined') {\n        cached = transform.parse(this.cache[type]);\n    }\n\n    var recvonlySsrcs = {\n        audio: {},\n        video: {}\n    };\n\n    // A helper map that sends mids to m-line objects. We use it later to\n    // rebuild the Unified Plan style session.media array.\n    var mid2ul = {};\n    var bIdx = 0;\n    var uIdx = 0;\n\n    var sources2ul = {};\n\n    var candidates;\n    var iceUfrag;\n    var icePwd;\n    var fingerprint;\n    var payloads = {};\n    var rtcpFb = {};\n    var rtp = {};\n\n    session.media.forEach(function(bLine) {\n        if ((typeof bLine.rtcpMux !== 'string' ||\n            bLine.rtcpMux !== 'rtcp-mux') &&\n            bLine.direction !== 'inactive') {\n            throw new Error(\"Cannot convert to Unified Plan because m-lines \" +\n                \"without the rtcp-mux attribute were found.\");\n        }\n\n        if (bLine.type === 'application') {\n            mid2ul[bLine.mid] = bLine;\n            return;\n        }\n\n        // With rtcp-mux and bundle all the channels should have the same ICE\n        // stuff.\n        var sources = bLine.sources;\n        var ssrcGroups = bLine.ssrcGroups;\n        var port = bLine.port;\n\n        /* Chrome adds different candidates even using bundle, so we concat the candidates list */\n        if (typeof bLine.candidates != 'undefined') {\n            if (typeof candidates != 'undefined') {\n                candidates = candidates.concat(bLine.candidates);\n            } else {\n                candidates = bLine.candidates;\n            }\n        }\n\n        if ((typeof iceUfrag != 'undefined') && (typeof bLine.iceUfrag != 'undefined') && (iceUfrag != bLine.iceUfrag)) {\n            throw new Error(\"Only BUNDLE supported, iceUfrag must be the same for all m-lines.\\n\" +\n                            \"\\tLast iceUfrag: \" + iceUfrag + \"\\n\" +\n                            \"\\tNew iceUfrag: \" + bLine.iceUfrag\n            );\n        }\n\n        if (typeof bLine.iceUfrag != 'undefined') {\n                iceUfrag = bLine.iceUfrag;\n        }\n\n        if ((typeof icePwd != 'undefined') && (typeof bLine.icePwd != 'undefined') && (icePwd != bLine.icePwd)) {\n            throw new Error(\"Only BUNDLE supported, icePwd must be the same for all m-lines.\\n\" +\n                            \"\\tLast icePwd: \" + icePwd + \"\\n\" +\n                            \"\\tNew icePwd: \" + bLine.icePwd\n            );\n        }\n\n        if (typeof bLine.icePwd != 'undefined') {\n                icePwd = bLine.icePwd;\n        }\n\n        if ((typeof fingerprint != 'undefined') && (typeof bLine.fingerprint != 'undefined') &&\n            (fingerprint.type != bLine.fingerprint.type || fingerprint.hash != bLine.fingerprint.hash)) {\n            throw new Error(\"Only BUNDLE supported, fingerprint must be the same for all m-lines.\\n\" +\n                            \"\\tLast fingerprint: \" + JSON.stringify(fingerprint) + \"\\n\" +\n                            \"\\tNew fingerprint: \" + JSON.stringify(bLine.fingerprint)\n            );\n        }\n\n        if (typeof bLine.fingerprint != 'undefined') {\n                fingerprint = bLine.fingerprint;\n        }\n\n        payloads[bLine.type] = bLine.payloads;\n        rtcpFb[bLine.type] = bLine.rtcpFb;\n        rtp[bLine.type] = bLine.rtp;\n\n        // inverted ssrc group map\n        var ssrc2group = {};\n        if (typeof ssrcGroups !== 'undefined' && Array.isArray(ssrcGroups)) {\n            ssrcGroups.forEach(function (ssrcGroup) {\n                // XXX This might brake if an SSRC is in more than one group\n                // for some reason.\n                if (typeof ssrcGroup.ssrcs !== 'undefined' &&\n                    Array.isArray(ssrcGroup.ssrcs)) {\n                    ssrcGroup.ssrcs.forEach(function (ssrc) {\n                        if (typeof ssrc2group[ssrc] === 'undefined') {\n                            ssrc2group[ssrc] = [];\n                        }\n\n                        ssrc2group[ssrc].push(ssrcGroup);\n                    });\n                }\n            });\n        }\n\n        // ssrc to m-line index.\n        var ssrc2ml = {};\n\n        if (typeof sources === 'object') {\n\n            // We'll use the \"bLine\" object as a prototype for each new \"mLine\"\n            // that we create, but first we need to clean it up a bit.\n            delete bLine.sources;\n            delete bLine.ssrcGroups;\n            delete bLine.candidates;\n            delete bLine.iceUfrag;\n            delete bLine.icePwd;\n            delete bLine.fingerprint;\n            delete bLine.port;\n            delete bLine.mid;\n\n            // Explode the Plan B channel sources with one m-line per source.\n            Object.keys(sources).forEach(function(ssrc) {\n\n                // The (unified) m-line for this SSRC. We either create it from\n                // scratch or, if it's a grouped SSRC, we re-use a related\n                // mline. In other words, if the source is grouped with another\n                // source, put the two together in the same m-line.\n                var uLine;\n\n                // We assume here that we are the answerer in the O/A, so any\n                // offers which we translate come from the remote side, while\n                // answers are local. So the check below is to make that we\n                // handle receive-only SSRCs in a special way only if they come\n                // from the remote side.\n                if (desc.type==='offer') {\n                    // We want to detect SSRCs which are used by a remote peer\n                    // in an m-line with direction=recvonly (i.e. they are\n                    // being used for RTCP only).\n                    // This information would have gotten lost if the remote\n                    // peer used Unified Plan and their local description was\n                    // translated to Plan B. So we use the lack of an MSID\n                    // attribute to deduce a \"receive only\" SSRC.\n                    if (!sources[ssrc].msid) {\n                        recvonlySsrcs[bLine.type][ssrc] = sources[ssrc];\n                        // Receive-only SSRCs must not create new m-lines. We\n                        // will assign them to an existing m-line later.\n                        return;\n                    }\n                }\n\n                if (typeof ssrc2group[ssrc] !== 'undefined' &&\n                    Array.isArray(ssrc2group[ssrc])) {\n                    ssrc2group[ssrc].some(function (ssrcGroup) {\n                        // ssrcGroup.ssrcs *is* an Array, no need to check\n                        // again here.\n                        return ssrcGroup.ssrcs.some(function (related) {\n                            if (typeof ssrc2ml[related] === 'object') {\n                                uLine = ssrc2ml[related];\n                                return true;\n                            }\n                        });\n                    });\n                }\n\n                if (typeof uLine === 'object') {\n                    // the m-line already exists. Just add the source.\n                    uLine.sources[ssrc] = sources[ssrc];\n                    delete sources[ssrc].msid;\n                } else {\n                    // Use the \"bLine\" as a prototype for the \"uLine\".\n                    uLine = Object.create(bLine);\n                    ssrc2ml[ssrc] = uLine;\n\n                    if (typeof sources[ssrc].msid !== 'undefined') {\n                        // Assign the msid of the source to the m-line. Note\n                        // that it is not guaranteed that the source will have\n                        // msid. In particular \"recvonly\" sources don't have an\n                        // msid. Note that \"recvonly\" is a term only defined\n                        // for m-lines.\n                        uLine.msid = sources[ssrc].msid;\n                        delete sources[ssrc].msid;\n                    }\n\n                    // We assign one SSRC per media line.\n                    uLine.sources = {};\n                    uLine.sources[ssrc] = sources[ssrc];\n                    uLine.ssrcGroups = ssrc2group[ssrc];\n\n                    // Use the cached Unified Plan SDP (if it exists) to assign\n                    // SSRCs to mids.\n                    if (typeof cached !== 'undefined' &&\n                        typeof cached.media !== 'undefined' &&\n                        Array.isArray(cached.media)) {\n\n                        cached.media.forEach(function (m) {\n                            if (typeof m.sources === 'object') {\n                                Object.keys(m.sources).forEach(function (s) {\n                                    if (s === ssrc) {\n                                        uLine.mid = m.mid;\n                                    }\n                                });\n                            }\n                        });\n                    }\n\n                    if (typeof uLine.mid === 'undefined') {\n\n                        // If this is an SSRC that we see for the first time\n                        // assign it a new mid. This is typically the case when\n                        // this method is called to transform a remote\n                        // description for the first time or when there is a\n                        // new SSRC in the remote description because a new\n                        // peer has joined the conference. Local SSRCs should\n                        // have already been added to the map in the toPlanB\n                        // method.\n                        //\n                        // Because FF generates answers in Unified Plan style,\n                        // we MUST already have a cached answer with all the\n                        // local SSRCs mapped to some m-line/mid.\n\n                        uLine.mid = [bLine.type, '-', ssrc].join('');\n                    }\n\n                    // Include the candidates in the 1st media line.\n                    uLine.candidates = candidates;\n                    uLine.iceUfrag = iceUfrag;\n                    uLine.icePwd = icePwd;\n                    uLine.fingerprint = fingerprint;\n                    uLine.port = port;\n\n                    mid2ul[uLine.mid] = uLine;\n                    sources2ul[uIdx] = uLine.sources;\n\n                    self.cache.mlU2BMap[uIdx] = bIdx;\n                    if (typeof self.cache.mlB2UMap[bIdx] === 'undefined') {\n                      self.cache.mlB2UMap[bIdx] = uIdx;\n                    }\n                    uIdx++;\n                }\n            });\n        } else {\n          var uLine = bLine;\n\n          uLine.candidates = candidates;\n          uLine.iceUfrag = iceUfrag;\n          uLine.icePwd = icePwd;\n          uLine.fingerprint = fingerprint;\n          uLine.port = port;\n\n          mid2ul[uLine.mid] = uLine;\n\n          self.cache.mlU2BMap[uIdx] = bIdx;\n          if (typeof self.cache.mlB2UMap[bIdx] === 'undefined') {\n            self.cache.mlB2UMap[bIdx] = uIdx;\n          }\n        }\n\n        bIdx++;\n    });\n\n    // Rebuild the media array in the right order and add the missing mLines\n    // (missing from the Plan B SDP).\n    session.media = [];\n    mids = []; // reuse\n\n    if (desc.type === 'answer') {\n\n        // The media lines in the answer must match the media lines in the\n        // offer. The order is important too. Here we assume that Firefox is\n        // the answerer, so we merely have to use the reconstructed (unified)\n        // answer to update the cached (unified) answer accordingly.\n        //\n        // In the general case, one would have to use the cached (unified)\n        // offer to find the m-lines that are missing from the reconstructed\n        // answer, potentially grabbing them from the cached (unified) answer.\n        // One has to be careful with this approach because inactive m-lines do\n        // not always have an mid, making it tricky (impossible?) to find where\n        // exactly and which m-lines are missing from the reconstructed answer.\n\n        for (var i = 0; i < cached.media.length; i++) {\n            var uLine = cached.media[i];\n\n            delete uLine.msid;\n            delete uLine.sources;\n            delete uLine.ssrcGroups;\n\n            if (typeof sources2ul[i] === 'undefined') {\n              if (!uLine.direction\n                  || uLine.direction === 'sendrecv')\n                  uLine.direction = 'recvonly';\n              else if (uLine.direction === 'sendonly')\n                  uLine.direction = 'inactive';\n            } else {\n              if (!uLine.direction\n                  || uLine.direction === 'sendrecv')\n                  uLine.direction = 'sendrecv';\n              else if (uLine.direction === 'recvonly')\n                  uLine.direction = 'sendonly';\n            }\n\n            uLine.sources = sources2ul[i];\n            uLine.candidates = candidates;\n            uLine.iceUfrag = iceUfrag;\n            uLine.icePwd = icePwd;\n            uLine.fingerprint = fingerprint;\n\n            uLine.rtp = rtp[uLine.type];\n            uLine.payloads = payloads[uLine.type];\n            uLine.rtcpFb = rtcpFb[uLine.type];\n\n            session.media.push(uLine);\n\n            if (typeof uLine.mid === 'string') {\n                // inactive lines don't/may not have an mid.\n                mids.push(uLine.mid);\n            }\n        }\n    } else {\n\n        // SDP offer/answer (and the JSEP spec) forbids removing an m-section\n        // under any circumstances. If we are no longer interested in sending a\n        // track, we just remove the msid and ssrc attributes and set it to\n        // either a=recvonly (as the reofferer, we must use recvonly if the\n        // other side was previously sending on the m-section, but we can also\n        // leave the possibility open if it wasn't previously in use), or\n        // a=inactive.\n\n        if (typeof cached !== 'undefined' &&\n            typeof cached.media !== 'undefined' &&\n            Array.isArray(cached.media)) {\n            cached.media.forEach(function(uLine) {\n                mids.push(uLine.mid);\n                if (typeof mid2ul[uLine.mid] !== 'undefined') {\n                    session.media.push(mid2ul[uLine.mid]);\n                } else {\n                    delete uLine.msid;\n                    delete uLine.sources;\n                    delete uLine.ssrcGroups;\n\n                    if (!uLine.direction\n                        || uLine.direction === 'sendrecv') {\n                        uLine.direction = 'sendonly';\n                    }\n                    if (!uLine.direction\n                        || uLine.direction === 'recvonly') {\n                        uLine.direction = 'inactive';\n                    }\n\n                    addSetupAttr (uLine);\n                    session.media.push(uLine);\n                }\n            });\n        }\n\n        // Add all the remaining (new) m-lines of the transformed SDP.\n        Object.keys(mid2ul).forEach(function(mid) {\n            if (mids.indexOf(mid) === -1) {\n                mids.push(mid);\n                if (mid2ul[mid].direction === 'recvonly') {\n                    // This is a remote recvonly channel. Add its SSRC to the\n                    // appropriate sendrecv or sendonly channel.\n                    // TODO(gp) what if we don't have sendrecv/sendonly\n                    // channel?\n\n                    var done = false;\n\n                    session.media.some(function (uLine) {\n                        if ((uLine.direction === 'sendrecv' ||\n                            uLine.direction === 'sendonly') &&\n                            uLine.type === mid2ul[mid].type) {\n                            // mid2ul[mid] shouldn't have any ssrc-groups\n                            Object.keys(mid2ul[mid].sources).forEach(\n                                function (ssrc) {\n                                uLine.sources[ssrc] =\n                                    mid2ul[mid].sources[ssrc];\n                            });\n\n                            done = true;\n                            return true;\n                        }\n                    });\n\n                    if (!done) {\n                        session.media.push(mid2ul[mid]);\n                    }\n                } else {\n                    session.media.push(mid2ul[mid]);\n                }\n            }\n        });\n    }\n\n    // After we have constructed the Plan Unified m-lines we can figure out\n    // where (in which m-line) to place the 'recvonly SSRCs'.\n    // Note: we assume here that we are the answerer in the O/A, so any offers\n    // which we translate come from the remote side, while answers are local\n    // (and so our last local description is cached as an 'answer').\n    [\"audio\", \"video\"].forEach(function (type) {\n        if (!session || !session.media || !Array.isArray(session.media))\n            return;\n\n        var idx = null;\n        if (Object.keys(recvonlySsrcs[type]).length > 0) {\n            idx = self.getFirstSendingIndexFromAnswer(type);\n            if (idx === null){\n                // If this is the first offer we receive, we don't have a\n                // cached answer. Assume that we will be sending media using\n                // the first m-line for each media type.\n\n                for (var i = 0; i < session.media.length; i++) {\n                    if (session.media[i].type === type) {\n                        idx = i;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (idx && session.media.length > idx) {\n            var mLine = session.media[idx];\n            Object.keys(recvonlySsrcs[type]).forEach(function(ssrc) {\n                if (mLine.sources && mLine.sources[ssrc]) {\n                    console.warn(\"Replacing an existing SSRC.\");\n                }\n                if (!mLine.sources) {\n                    mLine.sources = {};\n                }\n\n                mLine.sources[ssrc] = recvonlySsrcs[type][ssrc];\n            });\n        }\n    });\n\n    if (typeof session.groups !== 'undefined') {\n      // We regenerate the BUNDLE group (since we regenerated the mids)\n      session.groups.some(function(group) {\n\t  if (group.type === 'BUNDLE') {\n\t      group.mids = mids.join(' ');\n\t      return true;\n\t  }\n      });\n    }\n\n    // msid semantic\n    session.msidSemantic = {\n        semantic: 'WMS',\n        token: '*'\n    };\n\n    var resStr = transform.write(session);\n\n    // Cache the transformed SDP (Unified Plan) for later re-use in this\n    // function.\n    this.cache[desc.type] = resStr;\n\n    return new RTCSessionDescription({\n        type: desc.type,\n        sdp: resStr\n    });\n\n    //#endregion\n};\n"]},"metadata":{},"sourceType":"script"}